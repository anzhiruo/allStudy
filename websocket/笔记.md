# socket.io

### 简单聊天应用

> **通过下面的一个简单聊天demo,来入门socket.io**

#### 服务器端 - index.js

```
/* Chat application  --- 聊天应用 */
//引入express框架,并获得实例对象app.
var app = require('express')();
//引入http模块,并调用http模块的Server方法获得http实例对象
var http = require('http').Server(app);

/* 
这样就加载了 socket.io-client。 socket.io-client 暴露了一个 io 全局变量，然后连接服务器。
请注意我们在调用 io() 时没有指定任何 URL，因为它默认将尝试连接到提供当前页面的主机。
重新加载服务器和网站，你将看到控制台打印出 “a user connected”。
*/
//引入socket.io框架,并执行函数(socket.io模块暴露出来的是一个函数),传入http对象
var io = require('socket.io')(http);

//定义一个根路径路由,当客户访问时,返回根目录下的index.html文件
app.get('/', function (req, res) {
    //res.send('<h1>Hello world</h1>');
    res.sendFile(__dirname + '/index.html');
});

let count = 0; //记录当前用户连接的总数
//每当有用户连接的时候触发
io.on('connection', function (socket) {
    //每当有用户连接就自增 1
    count++;
    console.log('√有用户连接啦!-当前连接用户总数为:' + count + '位');

    //监听 聊天信息 事件
    socket.on('chat message', function (msg) {
    	//打印客户端传来的数据
        console.log('message: ' + msg);
        //为了简单起见，我们将消息发送给所有用户，包括发送者
        io.emit('chat message', msg);
    });

    //要将消息发给除特定 socket 外的其他用户，可以用 broadcast 标志：
    //socket.broadcast.emit('hi');

    //每个 socket 还会触发一个特殊的 disconnect 事件：用户断开连接的时候触发
    socket.on('disconnect', function () {
        count--;
        console.log('×有用户断开连接啦!-当前连接用户总数为:' + count + '位');
    });
});


//Socket.IO 的核心理念就是允许发送、接收任意事件和任意数据
//要将事件发送给每个用户，Socket.IO 提供了 io.emit 方法：
//io.emit('some event', { for: 'everyone' });

//监听3000端口
http.listen(3000, function () {
    console.log('listening on *:3000');
});
```



#### 客户端 - index.html

```
<!doctype html>
<html>

<head>
    <title>Socket.IO chat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font: 13px Helvetica, Arial;
        }

        form {
            background: #000;
            padding: 3px;
            position: fixed;
            bottom: 0;
            width: 100%;
        }

        form input {
            border: 0;
            padding: 10px;
            width: 90%;
            margin-right: .5%;
        }

        form button {
            width: 9%;
            background: rgb(130, 224, 255);
            border: none;
            padding: 10px;
        }

        #messages {
            list-style-type: none;
            margin: 0;
            padding: 0;
        }

        #messages li {
            padding: 5px 10px;
        }

        #messages li:nth-child(odd) {
            background: #eee;
        }
    </style>
</head>

<body>
    <!-- HTML部分 -->
    <ul id="messages"></ul>
    <form action="">
        <input id="m" autocomplete="off" /><button>Send</button>
    </form>

    <!-- JS部分 -->
    <!-- 引入socket文件 -->
    <script src="/socket.io/socket.io.js"></script>
   	<!-- 引入jQuery的文件 -->
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
    <script>
        $(function () {
            var socket = io();
            //发送消息到服务器端
            $('form').submit(function () {
            	//把form表单中的数据发送给服务器
                socket.emit('chat message', $('#m').val());
                $('#m').val('');
                return false;
            });
            //接收服务器端发送过来的消息
            socket.on('chat message', function (msg) {
            	//把服务器发送来的消息显示到页面上去
                $('#messages').append($('<li>').text(msg));
            });
        });
    </script>
</body>

</html>
```



### 总结一下

1.服务器端需要用到 http模块

2.io对象需要通过socket.io框架暴露的方法执行后得到,执行时需要传入http模块

3.io的on方法用于监听事件

4.socket.io框架中的事件有一些固定的名字,它们有各自的作用,自定义的事件不能与系统的事件重名



### 重点API

on方法监听客户端的所有动向

```
io.on('监听的事件名',回调函数(socket对象))
```

用户连接触发connection方法

```js
io.on('connection', function(socket){
  console.log('a user connected');
});
```

用户断开连接触发disconnect

```
//这里的socket为上面的回调传入的socket对象
socket.on('disconnect', function(){
    console.log('user disconnected');
});
```

自定义事件

```
socket.on('chat message', function(msg){
    console.log('message: ' + msg);
});
```

发送给所有用户，包括发送者

```
//emit方法的参数:1.事件名字 2.发送的数据
io.emit('chat message', msg);
```

发给除特定 socket 外的其他用户，可以用 broadcast 标志

```
socket.broadcast.emit('hi');
```

